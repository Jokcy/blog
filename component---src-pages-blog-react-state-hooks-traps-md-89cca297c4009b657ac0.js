(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{269:function(e,a,n){"use strict";n.r(a),n.d(a,"_frontmatter",function(){return c}),n.d(a,"default",function(){return i});n(37);var t=n(29),s=n.n(t),b=(n(0),n(99)),c={title:"React State Hooks 中存在的陷阱，在使用 Hooks 之前必须掌握",date:"2019-03-18",cover:"http://ww1.sinaimg.cn/large/a90af92bly1g0e2q3qzrvj20u00gwt95.jpg",description:"React Hooks 是 React18 版本正式开放的 API，其便利的使用方式，以及强大的逻辑抽离能力让所有 React 青睐。但是在使用 Hooks 的过程中有一些陷阱存在，如果你不明白他们的原因，那么你在使用 Hooks 的时候很可能就会出现问题...",tags:["react"]},p={_frontmatter:c},l="wrapper";function i(e){var a=e.components,n=s()(e,["components"]);return Object(b.b)(l,Object.assign({},p,n,{components:a,mdxType:"MDXLayout"}),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"伴随着 React Hooks 的正式发布，因为其易用性以及对于逻辑代码的复用性更强，毫无疑问越来越多的同学会偏向于使用 Hooks 来写自己的组件。但是随着使用的深入，我们发现了一些 State Hooks 的陷阱，那么今天我们就来分析一下 State Hooks 存在的一些陷阱，帮助同学们踩坑。")),Object(b.b)("p",null,"前几天在 twitter 上看到了一个关于 Hooks 的讨论，其内容围绕着下面的 demo："),Object(b.b)("iframe",{src:"https://codesandbox.io/embed/546p26y44x?fontsize=14&view=editor",style:{width:"100%",height:"500px",borderWidth:"0px",borderRadius:"4px",overflow:"hidden"},sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),Object(b.b)("p",null,"这里的代码想要实现的功能如下："),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"点击 Start 开始执行 interval，并且一旦有可能就往 ",Object(b.b)("inlineCode",{parentName:"li"},"lapse")," 上加一"),Object(b.b)("li",{parentName:"ul"},"点击 Stop 后取消 interval"),Object(b.b)("li",{parentName:"ul"},"点击 Clear 会取消 interval，并且设置 ",Object(b.b)("inlineCode",{parentName:"li"},"lapse")," 为 0")),Object(b.b)("p",null,"但是这个例子在实际执行过程中会出现一个问题，那就是在 interval 开启的情况下，直接执行 clear，会停止 interval，但是显示的 ",Object(b.b)("inlineCode",{parentName:"p"},"lapse")," 却不是 0，那么这是为什么呢？"),Object(b.b)("p",null,"出现这样的情况主要原因是：",Object(b.b)("inlineCode",{parentName:"p"},"useEffect")," 是异步的，也就是说我们执行 ",Object(b.b)("inlineCode",{parentName:"p"},"useEffect")," 中绑定的函数或者是解绑的函数，",Object(b.b)("strong",{parentName:"p"},"都不是在一次 ",Object(b.b)("inlineCode",{parentName:"strong"},"setState")," 产生的更新中被同步执行的。"),"啥意思呢？我们来模拟一下代码的执行顺序："),Object(b.b)("p",null,"在我们点击了 ",Object(b.b)("inlineCode",{parentName:"p"},"clear")," 之后，我们调用来 ",Object(b.b)("inlineCode",{parentName:"p"},"setLapse")," 和 ",Object(b.b)("inlineCode",{parentName:"p"},"setRunning"),"，这两个方法是用来更新 state 的，所以他们会标记组件更新，然后通知 React 我们需要重新渲染来。"),Object(b.b)("p",null,"然后 React 开始来重新渲染的流程，并很快执行到了 ",Object(b.b)("inlineCode",{parentName:"p"},"Stopwatch")," 组件。"),Object(b.b)("p",null,"注意以上都是同步执行的过程，所以不会存在在这个过程中 ",Object(b.b)("inlineCode",{parentName:"p"},"setInterval")," 又触发的情况，所以在更新 ",Object(b.b)("inlineCode",{parentName:"p"},"Stopwatch")," 的时候，如果我们能同步得执行 ",Object(b.b)("inlineCode",{parentName:"p"},"useEffect")," 的解绑函数，那么就可以在这次 JavaScript 的调用栈中清除这个 ",Object(b.b)("inlineCode",{parentName:"p"},"interval"),"，而不会出现这种情况。"),Object(b.b)("p",null,"但是恰恰因为 ",Object(b.b)("inlineCode",{parentName:"p"},"useEffect")," 是异步执行的，他要在 React 走完本次更新之后才会执行解绑以及重新绑定的函数。那么这就给 ",Object(b.b)("inlineCode",{parentName:"p"},"interval")," 再次触发的机会，",Object(b.b)("strong",{parentName:"p"},"这也就导致来，我们设置 ",Object(b.b)("inlineCode",{parentName:"strong"},"lapse")," 为 0 之后，他又在 ",Object(b.b)("inlineCode",{parentName:"strong"},"interval")," 中被更新成了一个计算后的值，之后才被真正的解绑。")),Object(b.b)("p",null,"那么我们如何解决这个问题呢？"),Object(b.b)("h3",null,"使用 ",Object(b.b)("inlineCode",{parentName:"h3"},"useLayoutEffect")),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 可以看作是 ",Object(b.b)("inlineCode",{parentName:"p"},"useEffect")," 的同步版本。使用 ",Object(b.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 就可以达到我们上面说的，在同一次更新流程中解绑 ",Object(b.b)("inlineCode",{parentName:"p"},"interval")," 的目的。"),Object(b.b)("p",null,"那么同学们肯定要问了，既然 ",Object(b.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 可以避免这个问题，那么为什么还要用 ",Object(b.b)("inlineCode",{parentName:"p"},"useEffect")," 呢，直接所有地方都用 ",Object(b.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 不就好了。"),Object(b.b)("p",null,"这个呢主要是因为 ",Object(b.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 是同步的，如果我们要在 ",Object(b.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 调用状态更新，或者执行一些非常耗时的计算，可能会导致 React 运行时间过长，阻塞了浏览器的渲染，导致一些卡顿的问题。这块呢我们有机会再单独写一篇文章来分析，这里就不再赘述。"),Object(b.b)("h3",null,"不使用 ",Object(b.b)("inlineCode",{parentName:"h3"},"useLayoutEffect")),Object(b.b)("p",null,"当然我们不能因为 ",Object(b.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 非常方便得解决了问题所以就直接抛弃 ",Object(b.b)("inlineCode",{parentName:"p"},"useEffect"),"，毕竟这是 React 更推荐的用法。那么我们该如何解决这个问题呢？"),Object(b.b)("p",null,"在解决问题之前，我们需要弄清楚问题的根本。在这个问题上，我们之前已经分析过，就是因为在我们设置了 ",Object(b.b)("inlineCode",{parentName:"p"},"lapse")," 之后，因为 ",Object(b.b)("inlineCode",{parentName:"p"},"interval")," 的再次触发，但是又设置了一次 ",Object(b.b)("inlineCode",{parentName:"p"},"lapse"),"。",Object(b.b)("strong",{parentName:"p"},"那么要解决这个问题，就可以通过避免最新的那次触发，或者在触发的时候判断如果没有 ",Object(b.b)("inlineCode",{parentName:"strong"},"running"),"，就不再设置。")),Object(b.b)("p",null,"使用 ",Object(b.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 显然属于第一种方法来解决问题，那么我们接下去来讲讲第二种方法。"),Object(b.b)("p",null,"按照这种思路，我们第一个反应应该就是在 ",Object(b.b)("inlineCode",{parentName:"p"},"setInterval")," 的回调中加入判断："),Object(b.b)("pre",null,Object(b.b)("code",Object.assign({parentName:"pre"},{className:"hljs language-js"}),Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"const")," intervalId = setInterval(",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-function"}),Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-params"}),"()")," =>")," {\n  ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"if")," (running) {\n    setLapse(",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-built_in"}),"Date"),".now() - startTime)\n  }\n}, ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-number"}),"0"),")")),Object(b.b)("p",null,"但是很遗憾，这样做是不行的，因为这个回调方法保存了他的闭包，而在他的闭包里面，",Object(b.b)("inlineCode",{parentName:"p"},"running")," 永远都是",Object(b.b)("inlineCode",{parentName:"p"},"true"),"。那么我们是否可以通过在 ",Object(b.b)("inlineCode",{parentName:"p"},"useEffect")," 外部声明方法来逃过闭包呢？比如下面这样："),Object(b.b)("pre",null,Object(b.b)("code",Object.assign({parentName:"pre"},{className:"hljs language-js"}),Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-function"}),Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-keyword"}),"function")," ",Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-title"}),"updateLapse"),"(",Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-params"}),"time"),") "),"{\n  ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"if")," (runing) {\n    setLapse(time)\n  }\n}\n\nReact.useEffect(",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-function"}),Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-params"}),"()")," =>")," {\n  ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-comment"}),"//..."),"\n  setInterval(",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-function"}),Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-params"}),"()")," =>")," {\n    updateLapse(",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-comment"}),"/* ... */"),")\n  })\n})")),Object(b.b)("p",null,"看上去 ",Object(b.b)("inlineCode",{parentName:"p"},"updateLapse")," 使用的是直接外部的 ",Object(b.b)("inlineCode",{parentName:"p"},"running"),"，所以不是 ",Object(b.b)("inlineCode",{parentName:"p"},"setInterval")," 回调保存的闭包来。但是可惜的是，这也是不行的。因为 ",Object(b.b)("inlineCode",{parentName:"p"},"updateLapse")," 也是 ",Object(b.b)("inlineCode",{parentName:"p"},"setInterval")," 闭包中的一部分，在这个闭包当中，",Object(b.b)("inlineCode",{parentName:"p"},"running")," 永远都是一开始的值。"),Object(b.b)("p",null,"可能看到这里大家会有点迷糊，主要就是对于闭包的层次的不太理解，这里我就专门提出来讲解一下。"),Object(b.b)("p",null,"在这里我们的组件是一个函数组件，他是一个纯粹的函数，没有 ",Object(b.b)("inlineCode",{parentName:"p"},"this"),"，同理也就没有 ",Object(b.b)("inlineCode",{parentName:"p"},"this.render")," 这样的在 ",Object(b.b)("inlineCode",{parentName:"p"},"ClassComponent")," 中特有的函数，所以每次我们渲染函数组件的时候，我们都是要执行这个方法的，在这里我们执行 ",Object(b.b)("inlineCode",{parentName:"p"},"Stopwatch"),"。"),Object(b.b)("p",null,"那么在开始执行的时候，我们就为 ",Object(b.b)("inlineCode",{parentName:"p"},"Stopwatch")," 创建来一个作用域，在这个作用域里面我们会声明方法，比如 ",Object(b.b)("inlineCode",{parentName:"p"},"updateLapse"),"，他是在这次执行 ",Object(b.b)("inlineCode",{parentName:"p"},"Stopwatch")," 的时候才声明的，每一次执行 ",Object(b.b)("inlineCode",{parentName:"p"},"Stopwatch")," 的时候都会声明 ",Object(b.b)("inlineCode",{parentName:"p"},"updateLapse"),"。同样的，",Object(b.b)("inlineCode",{parentName:"p"},"lapse")," 和 ",Object(b.b)("inlineCode",{parentName:"p"},"running")," 也是每个作用域里单独声明的，",Object(b.b)("strong",{parentName:"p"},"同一次声明的变量会出于同一个闭包，不同的声明在不同的闭包。"),"而 ",Object(b.b)("inlineCode",{parentName:"p"},"useEffect")," 只有在第一次渲染，或者后续 ",Object(b.b)("inlineCode",{parentName:"p"},"running")," 变化之后才会执行他的回调，所以对应的回调里面使用的闭包，也是每次执行的那次保存下来的。"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"这就导致来，在一个 ",Object(b.b)("inlineCode",{parentName:"strong"},"useEffect")," 内部是无法获知 ",Object(b.b)("inlineCode",{parentName:"strong"},"running")," 的变化的，这也是 ",Object(b.b)("inlineCode",{parentName:"strong"},"useEffct")," 提供第二个参数的原因。")),Object(b.b)("p",null,"那么是不是这里就无解了呢？明显不是的，这时候我们需要考虑使用 ",Object(b.b)("inlineCode",{parentName:"p"},"useReducer")," 来管理 ",Object(b.b)("inlineCode",{parentName:"p"},"state")),Object(b.b)("h3",null,"逃出闭包"),Object(b.b)("p",null,"我们先来看一下使用 ",Object(b.b)("inlineCode",{parentName:"p"},"useReducer")," 实现的代码："),Object(b.b)("iframe",{src:"https://codesandbox.io/embed/l2qkmm24jz?fontsize=14&view=editor",style:{width:"100%",height:"500px",borderWidth:"0px",borderRadius:"4px",overflow:"hidden"},sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),Object(b.b)("p",null,"在这里我们把 ",Object(b.b)("inlineCode",{parentName:"p"},"lapse")," 和 ",Object(b.b)("inlineCode",{parentName:"p"},"running")," 放在一起，变成了一个 ",Object(b.b)("inlineCode",{parentName:"p"},"state")," 对象，有点类似 Redux 的用法。在这里我们给 ",Object(b.b)("inlineCode",{parentName:"p"},"TICK")," action 上加了一个是否 ",Object(b.b)("inlineCode",{parentName:"p"},"running")," 的判断，以此来避开了在 ",Object(b.b)("inlineCode",{parentName:"p"},"running")," 被设置为 ",Object(b.b)("inlineCode",{parentName:"p"},"false")," 之后多余的 ",Object(b.b)("inlineCode",{parentName:"p"},"lapse")," 改变。"),Object(b.b)("p",null,"那么这个实现跟我们使用 ",Object(b.b)("inlineCode",{parentName:"p"},"updateLapse")," 的方式有什么区别呢？",Object(b.b)("strong",{parentName:"p"},"最大的区别是我们的 ",Object(b.b)("inlineCode",{parentName:"strong"},"state")," 不来自于闭包"),"，在之前的代码中，我们在任何方法中获取 ",Object(b.b)("inlineCode",{parentName:"p"},"lapse")," 和 ",Object(b.b)("inlineCode",{parentName:"p"},"running")," 都是通过闭包，而在这里，",Object(b.b)("inlineCode",{parentName:"p"},"state")," 是作为参数传入到 Reducer 中的，也就是不论何时我们调用了 ",Object(b.b)("inlineCode",{parentName:"p"},"dispatch"),"，在 Reducer 中得到的 State 都是最新的，这就帮助我们避开了闭包的问题。"),Object(b.b)("p",null,"其实我们也可以通过 ",Object(b.b)("inlineCode",{parentName:"p"},"useState")," 来实现，原理是一样的，我们可以通过把 ",Object(b.b)("inlineCode",{parentName:"p"},"lapse")," 和 ",Object(b.b)("inlineCode",{parentName:"p"},"running")," 放在一个对象中，然后使用"),Object(b.b)("pre",null,Object(b.b)("code",Object.assign({parentName:"pre"},{className:"hljs language-js"}),"updateState(newState) {\n  setState(",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-function"}),"(",Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-params"}),"state"),") =>")," ({ ...state, newState }))\n}")),Object(b.b)("p",null,"这样的方式来更新状态。这里最重要的就是给 ",Object(b.b)("inlineCode",{parentName:"p"},"setState")," 传入的是回调，这个回调会接受最新的状态，所以不需要使用闭包中的状态来进行判断。具体的代码我这边就不为大家实现来，大家可以去试一下，最终的代码应该类似下面的（没有测试过）："),Object(b.b)("pre",null,Object(b.b)("code",Object.assign({parentName:"pre"},{className:"hljs language-js"}),Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"const")," [state, dispatch] = React.useState(stateReducer, {\n  ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-attr"}),"lapse"),": ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-number"}),"0"),",\n  ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-attr"}),"running"),": ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-literal"}),"false"),",\n})\n\n",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-function"}),Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-keyword"}),"function")," ",Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-title"}),"updateState"),"(",Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-params"}),"action"),") "),"{\n  setState(",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-function"}),Object(b.b)("span",Object.assign({parentName:"span"},{className:"hljs-params"}),"state")," =>")," {\n    ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"switch")," (action.type) {\n      ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"case")," TOGGLE:\n        ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"return")," { ...state, ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-attr"}),"running"),": !state.running }\n      ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"case")," TICK:\n        ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"if")," (state.running) {\n          ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"return")," { ...state, ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-attr"}),"lapse"),": action.lapse }\n        }\n        ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"return")," state\n      ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"case")," CLEAR:\n        ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"return")," { ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-attr"}),"running"),": ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-literal"}),"false"),", ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-attr"}),"lapse"),": ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-number"}),"0")," }\n      ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"default"),":\n        ",Object(b.b)("span",Object.assign({parentName:"code"},{className:"hljs-keyword"}),"return")," state\n    }\n  })\n}")),Object(b.b)("p",null,"如果有问题非常欢迎跟我讨论哦。"),Object(b.b)("h3",null,"总结"),Object(b.b)("p",null,"相信看到这里大家应该已经有一些自己的心得了，关于 Hooks 使用上存在的一些问题，最主要的其实就是因为函数组件的特性带来的作用域和闭包问题，一旦你能够理清楚那么你就可以理解很多了。"),Object(b.b)("p",null,"当然我们肯定不仅仅是给大家一些建议，从这个 demo 中我们也总结出一些最佳实践："),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"讲相关的 state 最好放到一个对象中进行统一管理"),Object(b.b)("li",{parentName:"ul"},"使用更新方法的时候最好使用回调的方式，使用传入的状态，而不要使用闭包中的 state"),Object(b.b)("li",{parentName:"ul"},"管理复杂的状态可以考虑使用",Object(b.b)("inlineCode",{parentName:"li"},"useReducer"),"，或者类似的方式，对状态操作定义类型，执行不同的操作。")),Object(b.b)("p",null,"好了，以上就是这一次的分享，希望大家能收获一定的经验，避免以后在 Hooks 的使用中出现上面提到的这些问题。"))}i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-blog-react-state-hooks-traps-md-89cca297c4009b657ac0.js.map